import { NextResponse } from "next/server";
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import JSZip from "jszip";

const execAsync = promisify(exec);

export const runtime = "nodejs";
export const maxDuration = 600; // 10 minutes timeout for proving

interface ProveRequest {
  qapPath: string; // Path to QAP compiler library
  synthesizerPath: string; // Path to synthesizer output directory
  setupPath: string; // Path to setup output directory
  outputPath?: string; // Optional output path (defaults to temp directory)
}

async function assertPathExists(targetPath: string, kind: "file" | "dir") {
  try {
    const stat = await fs.stat(targetPath);
    if (kind === "file" && !stat.isFile()) {
      throw new Error(`Required file is not a file: ${targetPath}. Install Tokamak-zk-EVM first.`);
    }
    if (kind === "dir" && !stat.isDirectory()) {
      throw new Error(`Required directory is not a directory: ${targetPath}. Install Tokamak-zk-EVM first.`);
    }
  } catch (err: any) {
    if (err?.code === "ENOENT") {
      throw new Error(`Required ${kind} not found: ${targetPath}. Install Tokamak-zk-EVM first.`);
    }
    throw new Error(`Failed to access required ${kind}: ${targetPath}`);
  }
}

export async function POST(req: Request) {
  const distRoot = path.join(process.cwd(), "Tokamak-Zk-EVM", "dist");
  let outputDir: string | null = null;
  
  try {
    const body: ProveRequest = await req.json();
    const { qapPath, synthesizerPath, setupPath, outputPath } = body;

    // Validate inputs
    if (!qapPath || !synthesizerPath || !setupPath) {
      return NextResponse.json(
        { error: "Missing required fields: qapPath, synthesizerPath, setupPath" },
        { status: 400 }
      );
    }

    // Resolve absolute paths
    const qapPathAbs = path.isAbsolute(qapPath) ? qapPath : path.join(process.cwd(), qapPath);
    const synthesizerPathAbs = path.isAbsolute(synthesizerPath) ? synthesizerPath : path.join(process.cwd(), synthesizerPath);
    const setupPathAbs = path.isAbsolute(setupPath) ? setupPath : path.join(process.cwd(), setupPath);

    // Validate paths exist
    await assertPathExists(qapPathAbs, "dir");
    await assertPathExists(synthesizerPathAbs, "dir");
    await assertPathExists(setupPathAbs, "dir");

    // Create output directory
    if (outputPath) {
      outputDir = path.isAbsolute(outputPath) ? outputPath : path.join(process.cwd(), outputPath);
    } else {
      outputDir = path.join(distRoot, "outputs", `prove-${Date.now()}`);
    }
    await fs.mkdir(outputDir, { recursive: true });

    // Build command
    const binaryPath = path.join(distRoot, "bin", "prove");
    const libraryPath = path.join(distRoot, "backend-lib", "icicle", "lib");
    await assertPathExists(binaryPath, "file");
    await assertPathExists(libraryPath, "dir");

    const command = `"${binaryPath}" "${qapPathAbs}" "${synthesizerPathAbs}" "${setupPathAbs}" "${outputDir}"`;
    console.log("Executing prove command:", command);

    // Execute binary
    const { stdout, stderr } = await execAsync(command, {
      cwd: distRoot,
      timeout: 600000, // 10 minutes timeout
      env: {
        ...process.env,
        // Add library path for dynamic libraries
        DYLD_LIBRARY_PATH: libraryPath,
        ICICLE_BACKEND_INSTALL_DIR: path.join(libraryPath, "backend"),
      },
    });

    console.log("Prove stdout:", stdout);
    if (stderr) {
      console.warn("Prove stderr:", stderr);
    }

    // Read output files
    const outputFiles = await fs.readdir(outputDir);
    
    if (outputFiles.length === 0) {
      throw new Error("No output files generated by prove");
    }

    // Create ZIP file with all outputs
    const zip = new JSZip();
    
    for (const fileName of outputFiles) {
      const filePath = path.join(outputDir, fileName);
      const stat = await fs.stat(filePath);
      
      if (stat.isFile()) {
        const content = await fs.readFile(filePath);
        zip.file(fileName, content);
      }
    }

    // Generate ZIP buffer as Uint8Array and convert to Buffer for NextResponse
    const zipBuffer = await zip.generateAsync({ type: "uint8array" });
    const zipBufferNode = Buffer.from(zipBuffer);

    // Clean up output directory if it was temporary
    if (!outputPath) {
      try {
        await fs.rm(outputDir, { recursive: true, force: true });
      } catch (cleanupErr) {
        console.warn("Failed to clean up output directory:", cleanupErr);
      }
    }

    // Return ZIP file
    return new NextResponse(zipBufferNode, {
      status: 200,
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": `attachment; filename="proof-${Date.now()}.zip"`,
      },
    });
  } catch (error: any) {
    console.error("Failed to prove:", error);

    // Clean up output directory on error
    if (outputDir) {
      try {
        await fs.rm(outputDir, { recursive: true, force: true });
      } catch (cleanupErr) {
        console.warn("Failed to clean up output directory:", cleanupErr);
      }
    }

    // Extract meaningful error message from stderr if available
    let errorMessage = "Failed to generate proof";
    let errorDetails = error instanceof Error ? error.message : String(error);
    
    if (error?.stderr) {
      const stderrStr = String(error.stderr);
      if (stderrStr.includes("error:")) {
        const match = stderrStr.match(/error: (.+)/);
        if (match) {
          errorDetails = match[1];
        }
      }
    }

    return NextResponse.json(
      {
        error: errorMessage,
        details: errorDetails,
      },
      { status: 500 }
    );
  }
}

