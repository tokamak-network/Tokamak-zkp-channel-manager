import { NextResponse } from "next/server";
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import JSZip from "jszip";
import { bytesToHex } from "@ethereumjs/util";
import { deriveL2KeysFromSignature } from "@/Tokamak-Zk-EVM/packages/frontend/synthesizer/src/TokamakL2JS/utils/web.ts";

const execAsync = promisify(exec);

export const runtime = "nodejs";
export const maxDuration = 300; // 5 minutes timeout for long-running synthesis

interface SynthesizeL2TransferRequest {
  channelId: string;
  initTx: string;
  signature: `0x${string}`;
  recipient: string;
  amount: string;
  useSepolia?: boolean;
  previousStateSnapshot?: any; // State snapshot JSON object from latest verified proof
}

export async function POST(req: Request) {
  const outputDir = path.join(process.cwd(), "tokamak-zk-evm-bin", "outputs", `transfer-${Date.now()}`);
  let previousStateSnapshotPath: string | null = null;
  
  try {
    const body: SynthesizeL2TransferRequest = await req.json();
    const { channelId, initTx, signature, recipient, amount, useSepolia = true, previousStateSnapshot } = body;

    // Validate inputs
    if (!channelId || !initTx || !signature || !recipient || !amount) {
      return NextResponse.json(
        { error: "Missing required fields: channelId, initTx, signature, recipient, amount" },
        { status: 400 }
      );
    }

    // Derive L2 private key from signature
    const l2Keys = deriveL2KeysFromSignature(signature);
    const senderKey = bytesToHex(l2Keys.privateKey);
    console.log("Derived L2 sender key from signature");

    // Create output directory
    await fs.mkdir(outputDir, { recursive: true });

    // If previousStateSnapshot is provided, save it to a temporary file
    if (previousStateSnapshot) {
      previousStateSnapshotPath = path.join(outputDir, "previous_state_snapshot.json");
      await fs.writeFile(
        previousStateSnapshotPath,
        JSON.stringify(previousStateSnapshot, null, 2),
        "utf-8"
      );
      console.log("Saved previous state snapshot to:", previousStateSnapshotPath);
    }

    // Build RPC URL from environment variable
    const alchemyApiKey = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
    if (!alchemyApiKey) {
      throw new Error("NEXT_PUBLIC_ALCHEMY_API_KEY environment variable is not set");
    }
    const rpcUrl = `https://eth-sepolia.g.alchemy.com/v2/${alchemyApiKey}`;

    // Build command
    const binaryPath = path.join(process.cwd(), "tokamak-zk-evm-bin", "bin", "synthesizer");
    const args = [
      "l2-transfer",
      "--channel-id", channelId,
      "--init-tx", initTx,
      "--sender-key", senderKey,
      "--recipient", recipient,
      "--amount", amount,
      "--output", outputDir,
      "--rpc-url", rpcUrl,
    ];
    
    // Add --previous-state option if previousStateSnapshot is provided
    if (previousStateSnapshotPath) {
      args.push("--previous-state", previousStateSnapshotPath);
    }
    
    if (useSepolia) {
      args.push("--sepolia");
    }

    const command = `"${binaryPath}" ${args.join(" ")}`;
    console.log("Executing synthesizer command:", command);

    // Execute binary
    const { stdout, stderr } = await execAsync(command, {
      cwd: path.join(process.cwd(), "tokamak-zk-evm-bin"),
      timeout: 300000, // 5 minutes timeout
      env: {
        ...process.env,
        // Add library path for dynamic libraries
        DYLD_LIBRARY_PATH: path.join(process.cwd(), "tokamak-zk-evm-bin", "backend-lib", "icicle", "lib"),
      },
    });

    console.log("Synthesizer stdout:", stdout);
    if (stderr) {
      console.warn("Synthesizer stderr:", stderr);
    }

    // Read output files
    const outputFiles = await fs.readdir(outputDir);
    
    if (outputFiles.length === 0) {
      throw new Error("No output files generated by synthesizer");
    }

    // Create ZIP file with all outputs
    const zip = new JSZip();
    
    for (const fileName of outputFiles) {
      const filePath = path.join(outputDir, fileName);
      const stat = await fs.stat(filePath);
      
      if (stat.isFile()) {
        const content = await fs.readFile(filePath);
        zip.file(fileName, content);
      }
    }

    // Add transaction-info.json with channel and transfer details
    const transactionInfo = {
      channelId,
      initializationTxHash: initTx,
      recipient,
      amount,
      senderKey: senderKey,
      senderPublicKey: bytesToHex(l2Keys.publicKey),
      network: useSepolia ? "sepolia" : "mainnet",
      rpcUrl,
      generatedAt: new Date().toISOString(),
    };
    zip.file("transaction-info.json", JSON.stringify(transactionInfo, null, 2));

    // Generate ZIP buffer as Uint8Array and convert to Buffer for NextResponse
    const zipBuffer = await zip.generateAsync({ type: "uint8array" });
    const zipBufferNode = Buffer.from(zipBuffer);

    // Clean up output directory
    try {
      await fs.rm(outputDir, { recursive: true, force: true });
    } catch (cleanupErr) {
      console.warn("Failed to clean up output directory:", cleanupErr);
    }

    // Return ZIP file
    return new NextResponse(zipBufferNode, {
      status: 200,
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": `attachment; filename="l2-transfer-channel-${channelId}.zip"`,
      },
    });
  } catch (error: any) {
    console.error("Failed to synthesize L2 transfer:", error);

    // Clean up output directory on error
    try {
      await fs.rm(outputDir, { recursive: true, force: true });
    } catch (cleanupErr) {
      console.warn("Failed to clean up output directory:", cleanupErr);
    }
    
    // Clean up previous state snapshot file if it was created
    if (previousStateSnapshotPath) {
      try {
        await fs.unlink(previousStateSnapshotPath).catch(() => {});
      } catch (cleanupErr) {
        // Ignore cleanup errors for temp file
      }
    }

    // Extract meaningful error message from stderr if available
    let errorMessage = "Failed to synthesize L2 transfer";
    let errorDetails = error instanceof Error ? error.message : String(error);
    
    if (error?.stderr) {
      // Extract the actual error message from stderr
      const stderrStr = String(error.stderr);
      if (stderrStr.includes("Transfer failed:")) {
        errorMessage = "L2 Transfer synthesis failed";
        // Extract the specific error
        const match = stderrStr.match(/Transfer failed: (.+)/);
        if (match) {
          errorDetails = match[1];
        }
      } else if (stderrStr.includes("error:")) {
        const match = stderrStr.match(/error: (.+)/);
        if (match) {
          errorDetails = match[1];
        }
      }
    }

    return NextResponse.json(
      {
        error: errorMessage,
        details: errorDetails,
      },
      { status: 500 }
    );
  }
}

